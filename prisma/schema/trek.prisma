model Series {
  id       String    @id
  // memoryAlphaUrl String // TODO
  name     String
  episodes Episode[]
}

model Episode {
  id String @id @default(cuid())

  // memoryAlphaUrl String // TODO
  name         String
  abbreviation String?
  runtime      Int
  release      String
  starDate     Float?
  season       Int
  production   Int
  description  String

  seriesId   String
  series     Series      @relation(fields: [seriesId], references: [id])
  views      View[]
  opinions   Opinion[]
  watchlists Watchlist[]
  viewings   Viewing[]

  // The different ways to sort the episodes.
  // Each is a unique int in that col.
  // Not adding @unique tho becuase i want to easily update these
  sort Int

  @@unique([seriesId, season, production])
}

model Watchlist {
  id          String    @id @default(cuid())
  ownerId     String
  owner       Viewer    @relation(fields: [ownerId], references: [id])
  watchings   Viewing[]
  name        String
  description String
  /// JSON formatted string for the filters used to create this watchlist
  filters     String
  episodes    Episode[]

  createdAtId Int   @unique
  createdAt   Event @relation(fields: [createdAtId], references: [id])

  likes WatchlistLike[]
}

model Viewer {
  id         String      @id @default(cuid())
  email      Email       @relation("ViewerEmail", fields: [emailId], references: [id], onDelete: Cascade)
  emailId    String      @unique
  name       String
  views      View[]
  opinions   Opinion[]
  watchlists Watchlist[]
  viewings   Viewing[]
  /// JSON formatted string for the user's settings
  settings   String

  watchlistLikes WatchlistLike[]
  viewLikes      ViewLike[]
}

model Viewing {
  id          String    @id @default(cuid())
  state       String
  viewerId    String
  viewer      Viewer    @relation(fields: [viewerId], references: [id])
  cursor      String?
  episode     Episode?  @relation(fields: [cursor], references: [id], onDelete: SetNull)
  watchlistId String
  watchlist   Watchlist @relation(fields: [watchlistId], references: [id], onDelete: Cascade)

  startedAtId Int   @unique
  startedAt   Event @relation("StartedViewing", fields: [startedAtId], references: [id])

  finishedAtId Int?   @unique
  finsishedAt  Event? @relation("FinishedViewing", fields: [finishedAtId], references: [id])
}

model WatchlistLike {
  viewerId    String
  viewer      Viewer    @relation(fields: [viewerId], references: [id])
  watchlistId String
  watchlist   Watchlist @relation(fields: [watchlistId], references: [id])

  createdAtId Int   @unique
  createdAt   Event @relation(fields: [createdAtId], references: [id])

  @@id([viewerId, watchlistId])
}

model Opinion {
  viewerId  String
  viewer    Viewer  @relation(fields: [viewerId], references: [id])
  episodeId String
  episode   Episode @relation(fields: [episodeId], references: [id])

  liked  Boolean
  rating Int?

  @@id([viewerId, episodeId])
}

model View {
  id String @id @default(cuid())

  viewerId String
  viewer   Viewer @relation(fields: [viewerId], references: [id])

  episodeId String
  episode   Episode @relation(fields: [episodeId], references: [id])

  liked    Boolean
  rating   Int?
  comment  String?
  spoiler  Boolean
  viewedOn String?

  createdAtId Int   @unique
  createdAt   Event @relation(fields: [createdAtId], references: [id])

  tags Tag[]

  likes ViewLike[]
}

model ViewLike {
  viewerId String
  viewer   Viewer @relation(fields: [viewerId], references: [id])
  viewId   String
  view     View   @relation(fields: [viewId], references: [id])

  createdAtId Int   @unique
  createdAt   Event @relation(fields: [createdAtId], references: [id])

  @@id([viewerId, viewId])
}

model Tag {
  name  String @id
  views View[]
}

model Event {
  id   Int      @id @default(autoincrement())
  time DateTime @default(now())

  // TODO all of these should have an on delete cascade, right??? TEST THIS!!!
  view            View?
  watchlist       Watchlist?
  startedViewing  Viewing?       @relation("StartedViewing")
  finishedViewing Viewing?       @relation("FinishedViewing")
  viewLike        ViewLike?
  watchlistLike   WatchlistLike?
}
